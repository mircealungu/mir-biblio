Papers that I have co-authored

@inproceedings{Lung16a,
	Author = {Lungu, Mircea and Kurs, Jan},
	Title  = {Polite Programmers, Use Spaces in Identifiers When Needed},
	Note   = {To appear},
	Booktitle = {Proceedings of NOOL'16 (New Object Oriented Programming Languages)},
	Year   = {2016},
	Month  = nov,
	Url    = {https://github.com/mircealungu/Polite_Programmers__NOOL16/blob/master/preprint.pdf}
}


@inproceedings{Lung16b,
	Author = {Lungu, Mircea},
	Title  = {Bootstrapping an Ubiquitous Monitoring Ecosystem for Accelerating Vocabulary Acquisition},
	Note   = {To appear},
	Booktitle = {Proceedings of ECSAW'16},
	Year   = {2016},
	Month  = nov,
	doi    = {10.1145/2993412.3003389},
	Url    = {https://github.com/mircealungu/Bootstrapping_an_Ecosystem__WEA16/blob/master/preprint.pdf}
}



@inproceedings{Cara16b,
	Annote = {internationalconference},
	Author = {Andrea Caracciolo and Bledar Aga and Mircea Lungu and Oscar Nierstrasz},
	Title = {Marea: a Semi-automatic Decision Support System for Breaking Dependency Cycles},
	Abstract = {Dependency cycles are commonly recognized as one of the most critical quality anti-patterns. Cycles compromise the modularity of a system, prevent proper reuse and increase the cost of maintenance and testing. Many tools are capable of detecting and visualizing package cycles existing within software projects. Unfortunately, detecting cycles is only half of the work. Once detected, cycles need to be removed and this typically results in a complex process that is only partially supported by current tools. We propose a tool that offers an intelligent guidance mechanism to support developers in removing package cycles. Our tool, Marea, simulates different refactoring strategies and suggests the most cost-effective sequence of refactoring operations that will break the cycle. The optimal refactoring strategy is determined based on a custom profit function. Our approach has been validated on multiple projects and executes in linear time.},
	Keywords = {scg-pub snf-asa1 scg16 jb16 dicto-dsl},
	Booktitle = {Proceedings of the 23rd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
	PeerReview = {yes},
	Note = {to appear},
	Medium = {2},
	Year = {2016},
	month=mar,
	doi = {10.1109/SANER.2016.11},
	Url = {http://scg.unibe.ch/archive/papers/Cara16b.pdf}}
	
@inproceedings{Cara16c,
	Annote = {internationalworkshop},
	Author = {Andrea Caracciolo and Mircea Lungu and Oskar Truffer and Kirill Levitin and Oscar Nierstrasz},
	Title = {Evaluating an Architecture Conformance Monitoring Solution},
	Abstract = {Architectural rules are often defined but rarely tested. Current tools offer limited functionality and often require significant effort to be configured, automated and integrated within existing platforms. We propose a platform that is aimed at reducing the overall cost of setting up and maintaining an architectural conformance monitoring environment by decoupling the conceptual representation of a user-defined rule from its technical specification prescribed by the underlying analysis tools. The user is no longer expected to encode her constraints according to the syntax of the chosen tool, but can use a simple high-level DSL that is automatically compiled to an executable specification through custom adapters developed to support the interaction with existing off-the-shelf tools. In this paper we analyze three case studies to show how this approach can be successfully adopted to support truly diverse industrial projects. By discussing qualitative aspects of the approach, we investigate limitations and opportunities for improving general quality assessment solutions in general and DSL-based conformance tools in particular.},
	Keywords = {scg-pub snf-asa1 scg16 jb16 dicto-dsl arch-constr-eval},
	Booktitle = {Proceedings of the 7th IEEE International Workshop on Empirical Software Engineering in Practice (IWESEP)},
	doi = {10.1109/IWESEP.2016.12},
	PeerReview = {yes},
	Medium = {2},
	Year = {2016},
	month = mar,
	Url = {http://scg.unibe.ch/archive/papers/Cara16c.pdf}}
	
@misc{kurs16-polite,
  author       = {Kur\v{s}, Jan and
                  Lungu, Mircea and
                  Nierstrasz, Oscar and
                  Steinmann, Thomas},
  title        = {Polite Smalltalk - An Implementation},
  month        = sep,
  year         = 2016,
  doi          = {10.5281/zenodo.61578},
  url          = {https://doi.org/10.5281/zenodo.61578}
}

@inproceedings{Kurs16a,
	Abstract = {Parser combinators are a popular approach to parsing. Parser combinators follow the structure of an underlying grammar, are modular, well-structured, easy to maintain, and can recognize a large variety of languages including context-sensitive ones. However, their universality and flexibility introduces a noticeable performance overhead. Time-wise, parser combinators cannot compete with parsers generated by well-performing parser generators or optimized hand-written code.
Techniques exist to achieve a linear asymptotic performance of parser combinators, yet there is still a significant constant multiplier. This can be further lowered using meta-programming techniques.
In this work we present a more traditional approach to optimization --- a compiler --- applied to the domain of parser combinators. A parser combinator compiler (pc-compiler) analyzes a parser combinator, applies parser combinator-specific optimizations and, generates an equivalent high-performance top-down parser. Such a compiler preserves the advantages of parser combinators while complementing them with better performance.},
	Annote = {internationalworkshop},
	Author = {Jan Kur\v{s} and Jan Vran\'{y} and Mohammad Ghafari and Mircea Lungu and Oscar Nierstrasz},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2016)},
	Keywords = {scg16 scg-pub jb17 snf-asa2 missing-doi kursjan petitcompiler},
	Medium = {2},
	Peerreview = {yes},
	Title = {Optimizing Parser Combinators},
	Url = {http://scg.unibe.ch/archive/papers/Kurs16a-Compiler.pdf},
	Year = {2016},
	Note = {To Appear}
    }
    
@misc{Kurs16b,
  author       = {Kur\v{s}, Jan and Lungu, Mircea and Nierstrasz, Oscar and Steinmann, Thomas},
  title        = {Polite Smalltalk - An Implementation},
  abstract     = {Polite Smalltalk is a programming language
		that allows programmers to use sentence case identifiers -- a
		notation for embedding spaces in identifiers. We hope that a
		syntax like that of Polite will encourage developers to write
		more readable code. Even the smallest increase in code
		readability is to be desired since software developers spend
		the largest part of their time reading code rather than
		writing it.},
  keywords     = {scg16 scg-pub jb17 snf-none kursjan},
  month        = sep,
  year         = {2016},
  doi          = {10.5281/zenodo.61578},
  Medium       = {1},
  Peerreview   = {no},
  url          = {http://dx.doi.org/10.5281/zenodo.61578}
}

@inproceedings{Osma16a,
		Annote = {internationalconference},
		Author = {Haidar Osman and Manuel Leuenberger and Mircea Lungu and Oscar Nierstrasz},
		Title = {Tracking Null Checks in Open-Source {Java} Systems},
		Abstract = {It is widely acknowledged that null values should be avoided if possible or carefully used when necessary in Java code. The careless use of null has negative effects on maintainability, code readability, and software performance. However, a study on understanding null usage is still missing.
		In this paper we analyze null checks in 810 open-source Java systems and manually inspect 100 code samples to understand when and why developers use null. We find that 35% of all conditional statements contain null checks. A deeper investigation reveals many questionable practices with respect to using null. Uninitialized member variables, returning null in methods, and passing null as a method parameter are among the most recurrent reasons for introducing null checks. Developers often return null in methods to signal errors instead of throwing a proper exception. As a result, 71% of the values checked for null are returned from method calls.
		Our study provides a novel evidence of an overuse of null checks and of the null value itself in Java, and at the same time, reveals actionable recommendations to reduce this null usage.},
		Keywords = {scg-pub snf-asa2 jb16 scg16},
		Booktitle = {Proceedings of the 23rd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
		PeerReview = {yes},
		Medium = {2},
		Year = {2016},
		doi= {10.1109/SANER.2016.57},
		month=mar,
		Url = {http://scg.unibe.ch/archive/papers/Osma16a.pdf}}
		
@inproceedings{Spas16a,
	Annote = {internationalconference},
	Author = {Spasojevi\'{c}, Boris and Lungu, Mircea and Nierstrasz, Oscar},
	booktitle={2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
	Title = {A Case Study on Type Hints in Method Argument Names in {Pharo} {Smalltalk} Projects},
	Abstract = {A common practice when writing Smalltalk source code is to name method arguments in a way that hints at their expected type (i.e., aString, anInteger, aDictionary). This practice makes code more readable, but the prevalence of this practice is unknown, thus its reliability is questionable. Tools such as the auto complete feature in the Pharo Smalltalk code editor rely on these hints to improve the developer experience. The default algorithm used in Pharo to extract type information from these hints succeeds in extracting a type in slightly over 36% of method arguments taken from 114 Pharo projects. In this paper we present the results of analyzing the failing method argument names, and provide several simple heuristics that can increase the rate of success to slightly over 50%. We also present a case study on the relation between type hints and run-time types of method arguments that shows that type hints, in a great majority of cases, reflect run-time types.},
	Keywords = {scg-pub snf-asa1 scg16 Spasojevic},
	PeerReview = {yes},
	Medium = {2},
	volume={1},
	pages={283-292},
	Year = {2016},
	month=mar,
	Keywords = {scg-pub snf-asa1 scg16 jb16 Spasojevic},
	doi={10.1109/SANER.2016.41},
	Url = {http://scg.unibe.ch/archive/papers/Spas16a.pdf}
	}
	
	
	
	
	
@inproceedings{Haen14a,
	Annote = {internationalworkshop},
	Abstract = {We present the results of an investigation into the nature of information needs of software developers who work in projects that are part of larger ecosystems. This work is based on a quantitative survey of 75 professional software developers. We corroborate the results identified in the sur- vey with needs and motivations proposed in a previous sur- vey and discover that tool support for developers working in an ecosystem context is even more meager than we thought: mailing lists and internet search are the most popular tools developers use to satisfy their ecosystem-related information needs.},
	Author = {Haenni, Nicole and Lungu, Mircea and Schwarz, Niko and Nierstrasz, Oscar},
	Booktitle = {Proceedings of the 2nd Workshop on Ecosystem Architectures (WEA'14)},
	Keywords = {ecosystems scg-pub snf-asa1 scg14 jb14},
	Medium = {2},
	Pages = {1--6},
	Peerreview = {yes},
	Title = {A Quantitative Analysis of Developer Information Needs in Software Ecosystems},
	Url = {http://scg.unibe.ch/archive/papers/Haen14a-QuantitativeEcosystemInformationNeeds.pdf},
	Doi = {10.1145/2642803.2642815},
	Year = {2014},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Haen14a-QuantitativeEcosystemInformationNeeds.pdf}}


@inproceedings{Haen13a,
	Annote = {internationalworkshop},
	Abstract = {We present the results of an investigation into the nature of the information needs of software developers who work in projects that are part of larger ecosystems. In an open-question survey we asked framework and library developers about their information needs with respect to both their upstream and downstream projects. We investigated what kind of information is required, why is it necessary, and how the developers obtain this information.
	The results show that the downstream needs are grouped into three categories roughly corresponding to the different stages in their relation with an upstream: selection, adoption, and co-evolution. The less numerous upstream needs are grouped into two categories: project statistics and code usage.
	The current practices part of the study shows that to satisfy many of these needs developers use non-specific tools and ad hoc methods. We believe that this is a largely unexplored area of research.},
	Author = {Haenni, Nicole and Lungu, Mircea and Schwarz, Niko and Nierstrasz, Oscar},
	Booktitle = {Proceedings of the 1st Workshop on Ecosystem Architectures},
	Keywords = {ecosystems scg-pub snf-asa1 scg13 skip-doi jb14},
	Medium = {2},
	Pages = {1--5},
	Peerreview = {yes},
	Title = {Categorizing Developer Information Needs in Software Ecosystems},
	Url = {http://scg.unibe.ch/archive/papers/Haen13a-EcosystemInformationNeeds.pdf},
	Year = {2013},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Haen13a-EcosystemInformationNeeds.pdf}}


